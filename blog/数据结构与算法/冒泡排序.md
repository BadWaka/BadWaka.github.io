> 感谢“啊哈磊”大神的神奇算法书~《啊哈！算法》
> 鼎力推荐

冒泡算法的核心思想就是**交换**
一个一个的交换，一轮一轮的交换
每一轮的目的就是把数归位

----------
比如448 75 98 26 12这五个数从小到大排列，
先从左边第一个开始，448大于75，交换，数组为 75 448  98 26 12,**把大的数移到后一位**
448大于98，交换，数组为 75 98 448 26 12
448大于24，交换，数组为 75 98 26 448 12
448大于12，交换，数组为 75 98 26 12 448
至此，第一轮结束，**目的就是把最大的数移到最后一位**

然后第二轮再从最左边开始，**目的就是把第二大的数移到倒数第二位**，以此类推

一共N个数，循环N-1轮即可


----------
作为一个Android程序员，我是比较喜欢用Java的，但是最近在研究NDK，C/C++已经忘得差不多了，得好好复习一下
所以写了两遍，强化记忆顺便练习C/C++


----------
下面是C代码（使用IDE是Visual Studio 2015  Community）：
```
#include <stdio.h>

int main() {
	int a[100], n, t = 0;
	scanf_s("%d", &n, 1);//输入一个数n，表示接下来有n个;ANSI C中没有scanf_s(),只有scanf()，scanf()在读取时不检查边界，所以可能会造成内在泄露。所以vc++2005/2008中提供了scanf_s(),在调用时，必须提供一个数字以表明最多读取多少位字符

	//循环读入n个数到数组中
	for (int i = 0; i < n; i++) {
		scanf_s("%d", &a[i], 1);
	}

	//冒泡排序核心部分
	for (int i = 0; i < n - 1; i++) {//n个数排序，只用进行n-1趟
		for (int j = 0; j < n - 1 - i; j++) {//j<n-1-i这句很重要，从第一位一直比到最后一个尚未归为的数
			//从大到小排
			if (a[j] > a[j + 1]) {
				t = a[j];
				a[j] = a[j + 1];
				a[j + 1] = t;
			}
		}
	}

	//输出结果
	for (int i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}

	getchar();
	getchar();
	return 0;
}
```
![这里写图片描述](http://img.blog.csdn.net/20160116135952658)

----------
Java代码（使用IDE是 IntelliJ IDEA）：

```
package com.waka.workspace;

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        int[] a = new int[100];
        int n, t;

        Scanner in = new Scanner(System.in);
        n = in.nextInt();//输入n

        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }

        //冒泡排序核心部分
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - 1 - i; j++) {
                if (a[j] > a[j + 1]) {//从小到大排序
                    t = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = t;
                }
            }
        }

        //输出到屏幕上
        for (int i = 0; i < n; i++) {
            System.out.print(a[i] + " ");
        }

    }
}

```
![这里写图片描述](http://img.blog.csdn.net/20160116135905682)

----------
值得一提的是，冒泡排序的时间复杂度很高，
冒泡排序的核心部分是双重嵌套循环，它的**时间复杂度是O(N^2)**；
所以在数据量较大的情况下，是极不推荐的排序算法。 


 